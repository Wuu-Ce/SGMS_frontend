{"resolvedId":"D:/Web/gms_forntend/node_modules/.vite/deps/pinia-plugin-persistedstate.js?v=9bf8341e","transforms":[{"name":"vite:optimized-deps","result":"import \"./chunk-TWLJ45QX.js\";\n\n// node_modules/.pnpm/pinia-plugin-persistedstate@2.2.0_pinia@2.0.22/node_modules/pinia-plugin-persistedstate/dist/chunk-HKUFGHKP.mjs\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */ Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\nfunction isObject2(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction merge(destination, source) {\n  const mergingArrays = Array.isArray(destination) && Array.isArray(source);\n  const mergingObjects = isObject2(destination) && isObject2(source);\n  if (!mergingArrays && !mergingObjects) {\n    throw new Error(\"Can only merge object with object or array with array\");\n  }\n  const result = mergingArrays ? [] : {};\n  const keys = [...Object.keys(destination), ...Object.keys(source)];\n  keys.forEach((key) => {\n    if (Array.isArray(destination[key]) && Array.isArray(source[key])) {\n      result[key] = [\n        ...Object.values(\n          merge(destination[key], source[key])\n        )\n      ];\n    } else if (source[key] !== null && typeof source[key] === \"object\" && typeof destination[key] === \"object\") {\n      result[key] = merge(\n        destination[key],\n        source[key]\n      );\n    } else if (destination[key] !== void 0 && source[key] === void 0) {\n      result[key] = destination[key];\n    } else if (destination[key] === void 0 && source[key] !== void 0) {\n      result[key] = source[key];\n    }\n  });\n  return result;\n}\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    if (p === \"[]\" && Array.isArray(obj))\n      return obj;\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  const modifiedState = path.slice(0, -1).reduce((obj, p) => {\n    if (!/^(__proto__)$/.test(p))\n      return obj[p] = obj[p] || {};\n    else\n      return {};\n  }, state);\n  if (Array.isArray(modifiedState[path[path.length - 1]]) && Array.isArray(val)) {\n    const merged = modifiedState[path[path.length - 1]].map(\n      (item, index) => {\n        if (Array.isArray(item) && typeof item !== \"object\") {\n          return [...item, ...val[index]];\n        }\n        if (typeof item === \"object\" && item !== null && Object.keys(item).some((key) => Array.isArray(item[key]))) {\n          return merge(item, val[index]);\n        }\n        return {\n          ...item,\n          ...val[index]\n        };\n      }\n    );\n    modifiedState[path[path.length - 1]] = merged;\n  } else if (path[path.length - 1] === void 0 && Array.isArray(modifiedState) && Array.isArray(val)) {\n    modifiedState.push(...val);\n  } else {\n    modifiedState[path[path.length - 1]] = val;\n  }\n  return state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce(\n    (substate, path) => {\n      const pathArray = path.split(\".\");\n      if (!pathArray.includes(\"[]\")) {\n        return set(substate, pathArray, get(baseState, pathArray));\n      }\n      const arrayIndex = pathArray.indexOf(\"[]\");\n      const pathArrayBeforeArray = pathArray.slice(0, arrayIndex);\n      const pathArrayUntilArray = pathArray.slice(0, arrayIndex + 1);\n      const pathArrayAfterArray = pathArray.slice(arrayIndex + 1);\n      const referencedArray = get(\n        baseState,\n        pathArrayUntilArray\n      );\n      const referencedArraySubstate = [];\n      for (const item of referencedArray) {\n        if (pathArrayAfterArray.length !== 0 && (Array.isArray(item) || typeof item === \"object\")) {\n          referencedArraySubstate.push(\n            pick(item, [pathArrayAfterArray.join(\".\")])\n          );\n        } else {\n          referencedArraySubstate.push(item);\n        }\n      }\n      return set(substate, pathArrayBeforeArray, referencedArraySubstate);\n    },\n    Array.isArray(baseState) ? [] : {}\n  );\n}\nfunction hydrateStore(store, storage, serializer, key) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage)\n      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (_error) {\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return (context) => {\n    const {\n      options: { persist },\n      store\n    } = context;\n    if (!persist)\n      return;\n    const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(\n      ({\n        storage = localStorage,\n        beforeRestore = null,\n        afterRestore = null,\n        serializer = {\n          serialize: JSON.stringify,\n          deserialize: JSON.parse\n        },\n        key = store.$id,\n        paths = null\n      }) => ({\n        storage,\n        beforeRestore,\n        afterRestore,\n        serializer,\n        key,\n        paths\n      })\n    );\n    persistences.forEach((p) => {\n      const { storage, serializer, key, paths, beforeRestore, afterRestore } = p;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, storage, serializer, key);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe(\n        (_mutation, state) => {\n          try {\n            const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n            storage.setItem(key, serializer.serialize(toStore));\n          } catch (_error) {\n          }\n        },\n        {\n          detached: true\n        }\n      );\n    });\n    store.$hydrate = ({ runHooks = true } = {}) => {\n      persistences.forEach((p) => {\n        const { beforeRestore, afterRestore, storage, serializer, key } = p;\n        if (runHooks)\n          beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, storage, serializer, key);\n        if (runHooks)\n          afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n  };\n}\n\n// node_modules/.pnpm/pinia-plugin-persistedstate@2.2.0_pinia@2.0.22/node_modules/pinia-plugin-persistedstate/dist/index.mjs\nvar src_default = createPersistedState();\n\n// dep:pinia-plugin-persistedstate\nvar pinia_plugin_persistedstate_default = src_default;\nexport {\n  createPersistedState,\n  pinia_plugin_persistedstate_default as default\n};\n//# sourceMappingURL=pinia-plugin-persistedstate.js.map\n","start":1663662531649,"end":1663662532146},{"name":"vite-plugin-use-modules","result":"import \"./chunk-TWLJ45QX.js\";\n\n// node_modules/.pnpm/pinia-plugin-persistedstate@2.2.0_pinia@2.0.22/node_modules/pinia-plugin-persistedstate/dist/chunk-HKUFGHKP.mjs\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */ Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\nfunction isObject2(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction merge(destination, source) {\n  const mergingArrays = Array.isArray(destination) && Array.isArray(source);\n  const mergingObjects = isObject2(destination) && isObject2(source);\n  if (!mergingArrays && !mergingObjects) {\n    throw new Error(\"Can only merge object with object or array with array\");\n  }\n  const result = mergingArrays ? [] : {};\n  const keys = [...Object.keys(destination), ...Object.keys(source)];\n  keys.forEach((key) => {\n    if (Array.isArray(destination[key]) && Array.isArray(source[key])) {\n      result[key] = [\n        ...Object.values(\n          merge(destination[key], source[key])\n        )\n      ];\n    } else if (source[key] !== null && typeof source[key] === \"object\" && typeof destination[key] === \"object\") {\n      result[key] = merge(\n        destination[key],\n        source[key]\n      );\n    } else if (destination[key] !== void 0 && source[key] === void 0) {\n      result[key] = destination[key];\n    } else if (destination[key] === void 0 && source[key] !== void 0) {\n      result[key] = source[key];\n    }\n  });\n  return result;\n}\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    if (p === \"[]\" && Array.isArray(obj))\n      return obj;\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  const modifiedState = path.slice(0, -1).reduce((obj, p) => {\n    if (!/^(__proto__)$/.test(p))\n      return obj[p] = obj[p] || {};\n    else\n      return {};\n  }, state);\n  if (Array.isArray(modifiedState[path[path.length - 1]]) && Array.isArray(val)) {\n    const merged = modifiedState[path[path.length - 1]].map(\n      (item, index) => {\n        if (Array.isArray(item) && typeof item !== \"object\") {\n          return [...item, ...val[index]];\n        }\n        if (typeof item === \"object\" && item !== null && Object.keys(item).some((key) => Array.isArray(item[key]))) {\n          return merge(item, val[index]);\n        }\n        return {\n          ...item,\n          ...val[index]\n        };\n      }\n    );\n    modifiedState[path[path.length - 1]] = merged;\n  } else if (path[path.length - 1] === void 0 && Array.isArray(modifiedState) && Array.isArray(val)) {\n    modifiedState.push(...val);\n  } else {\n    modifiedState[path[path.length - 1]] = val;\n  }\n  return state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce(\n    (substate, path) => {\n      const pathArray = path.split(\".\");\n      if (!pathArray.includes(\"[]\")) {\n        return set(substate, pathArray, get(baseState, pathArray));\n      }\n      const arrayIndex = pathArray.indexOf(\"[]\");\n      const pathArrayBeforeArray = pathArray.slice(0, arrayIndex);\n      const pathArrayUntilArray = pathArray.slice(0, arrayIndex + 1);\n      const pathArrayAfterArray = pathArray.slice(arrayIndex + 1);\n      const referencedArray = get(\n        baseState,\n        pathArrayUntilArray\n      );\n      const referencedArraySubstate = [];\n      for (const item of referencedArray) {\n        if (pathArrayAfterArray.length !== 0 && (Array.isArray(item) || typeof item === \"object\")) {\n          referencedArraySubstate.push(\n            pick(item, [pathArrayAfterArray.join(\".\")])\n          );\n        } else {\n          referencedArraySubstate.push(item);\n        }\n      }\n      return set(substate, pathArrayBeforeArray, referencedArraySubstate);\n    },\n    Array.isArray(baseState) ? [] : {}\n  );\n}\nfunction hydrateStore(store, storage, serializer, key) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage)\n      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (_error) {\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return (context) => {\n    const {\n      options: { persist },\n      store\n    } = context;\n    if (!persist)\n      return;\n    const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(\n      ({\n        storage = localStorage,\n        beforeRestore = null,\n        afterRestore = null,\n        serializer = {\n          serialize: JSON.stringify,\n          deserialize: JSON.parse\n        },\n        key = store.$id,\n        paths = null\n      }) => ({\n        storage,\n        beforeRestore,\n        afterRestore,\n        serializer,\n        key,\n        paths\n      })\n    );\n    persistences.forEach((p) => {\n      const { storage, serializer, key, paths, beforeRestore, afterRestore } = p;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, storage, serializer, key);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe(\n        (_mutation, state) => {\n          try {\n            const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n            storage.setItem(key, serializer.serialize(toStore));\n          } catch (_error) {\n          }\n        },\n        {\n          detached: true\n        }\n      );\n    });\n    store.$hydrate = ({ runHooks = true } = {}) => {\n      persistences.forEach((p) => {\n        const { beforeRestore, afterRestore, storage, serializer, key } = p;\n        if (runHooks)\n          beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, storage, serializer, key);\n        if (runHooks)\n          afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n  };\n}\n\n// node_modules/.pnpm/pinia-plugin-persistedstate@2.2.0_pinia@2.0.22/node_modules/pinia-plugin-persistedstate/dist/index.mjs\nvar src_default = createPersistedState();\n\n// dep:pinia-plugin-persistedstate\nvar pinia_plugin_persistedstate_default = src_default;\nexport {\n  createPersistedState,\n  pinia_plugin_persistedstate_default as default\n};\n//# sourceMappingURL=pinia-plugin-persistedstate.js.map\n","start":1663662532148,"end":1663662532148,"order":"normal"},{"name":"vite:import-analysis","result":"import \"/node_modules/.vite/deps/chunk-TWLJ45QX.js?v=b1656508\";\n\n// node_modules/.pnpm/pinia-plugin-persistedstate@2.2.0_pinia@2.0.22/node_modules/pinia-plugin-persistedstate/dist/chunk-HKUFGHKP.mjs\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */ Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\nfunction isObject2(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction merge(destination, source) {\n  const mergingArrays = Array.isArray(destination) && Array.isArray(source);\n  const mergingObjects = isObject2(destination) && isObject2(source);\n  if (!mergingArrays && !mergingObjects) {\n    throw new Error(\"Can only merge object with object or array with array\");\n  }\n  const result = mergingArrays ? [] : {};\n  const keys = [...Object.keys(destination), ...Object.keys(source)];\n  keys.forEach((key) => {\n    if (Array.isArray(destination[key]) && Array.isArray(source[key])) {\n      result[key] = [\n        ...Object.values(\n          merge(destination[key], source[key])\n        )\n      ];\n    } else if (source[key] !== null && typeof source[key] === \"object\" && typeof destination[key] === \"object\") {\n      result[key] = merge(\n        destination[key],\n        source[key]\n      );\n    } else if (destination[key] !== void 0 && source[key] === void 0) {\n      result[key] = destination[key];\n    } else if (destination[key] === void 0 && source[key] !== void 0) {\n      result[key] = source[key];\n    }\n  });\n  return result;\n}\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    if (p === \"[]\" && Array.isArray(obj))\n      return obj;\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  const modifiedState = path.slice(0, -1).reduce((obj, p) => {\n    if (!/^(__proto__)$/.test(p))\n      return obj[p] = obj[p] || {};\n    else\n      return {};\n  }, state);\n  if (Array.isArray(modifiedState[path[path.length - 1]]) && Array.isArray(val)) {\n    const merged = modifiedState[path[path.length - 1]].map(\n      (item, index) => {\n        if (Array.isArray(item) && typeof item !== \"object\") {\n          return [...item, ...val[index]];\n        }\n        if (typeof item === \"object\" && item !== null && Object.keys(item).some((key) => Array.isArray(item[key]))) {\n          return merge(item, val[index]);\n        }\n        return {\n          ...item,\n          ...val[index]\n        };\n      }\n    );\n    modifiedState[path[path.length - 1]] = merged;\n  } else if (path[path.length - 1] === void 0 && Array.isArray(modifiedState) && Array.isArray(val)) {\n    modifiedState.push(...val);\n  } else {\n    modifiedState[path[path.length - 1]] = val;\n  }\n  return state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce(\n    (substate, path) => {\n      const pathArray = path.split(\".\");\n      if (!pathArray.includes(\"[]\")) {\n        return set(substate, pathArray, get(baseState, pathArray));\n      }\n      const arrayIndex = pathArray.indexOf(\"[]\");\n      const pathArrayBeforeArray = pathArray.slice(0, arrayIndex);\n      const pathArrayUntilArray = pathArray.slice(0, arrayIndex + 1);\n      const pathArrayAfterArray = pathArray.slice(arrayIndex + 1);\n      const referencedArray = get(\n        baseState,\n        pathArrayUntilArray\n      );\n      const referencedArraySubstate = [];\n      for (const item of referencedArray) {\n        if (pathArrayAfterArray.length !== 0 && (Array.isArray(item) || typeof item === \"object\")) {\n          referencedArraySubstate.push(\n            pick(item, [pathArrayAfterArray.join(\".\")])\n          );\n        } else {\n          referencedArraySubstate.push(item);\n        }\n      }\n      return set(substate, pathArrayBeforeArray, referencedArraySubstate);\n    },\n    Array.isArray(baseState) ? [] : {}\n  );\n}\nfunction hydrateStore(store, storage, serializer, key) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage)\n      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (_error) {\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return (context) => {\n    const {\n      options: { persist },\n      store\n    } = context;\n    if (!persist)\n      return;\n    const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(\n      ({\n        storage = localStorage,\n        beforeRestore = null,\n        afterRestore = null,\n        serializer = {\n          serialize: JSON.stringify,\n          deserialize: JSON.parse\n        },\n        key = store.$id,\n        paths = null\n      }) => ({\n        storage,\n        beforeRestore,\n        afterRestore,\n        serializer,\n        key,\n        paths\n      })\n    );\n    persistences.forEach((p) => {\n      const { storage, serializer, key, paths, beforeRestore, afterRestore } = p;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, storage, serializer, key);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe(\n        (_mutation, state) => {\n          try {\n            const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n            storage.setItem(key, serializer.serialize(toStore));\n          } catch (_error) {\n          }\n        },\n        {\n          detached: true\n        }\n      );\n    });\n    store.$hydrate = ({ runHooks = true } = {}) => {\n      persistences.forEach((p) => {\n        const { beforeRestore, afterRestore, storage, serializer, key } = p;\n        if (runHooks)\n          beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, storage, serializer, key);\n        if (runHooks)\n          afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n  };\n}\n\n// node_modules/.pnpm/pinia-plugin-persistedstate@2.2.0_pinia@2.0.22/node_modules/pinia-plugin-persistedstate/dist/index.mjs\nvar src_default = createPersistedState();\n\n// dep:pinia-plugin-persistedstate\nvar pinia_plugin_persistedstate_default = src_default;\nexport {\n  createPersistedState,\n  pinia_plugin_persistedstate_default as default\n};\n//# sourceMappingURL=pinia-plugin-persistedstate.js.map\n","start":1663662532148,"end":1663662532148,"order":"normal"}]}
